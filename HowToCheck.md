## 实验验收流程

实验一共有三个部分的要求，第一部分是实现 `Homework` 下面的几个题目，要求在 OJ 上提交并通过；第二部分是针对个人的测试，主要测试转发和RIP协议的细节；第三部分是针对组队的测试，只要保证连通性，即可通过，如果采用更加复杂的网络拓扑也能达到预期目标，可以得到加分。

<details>
    <summary> CIDR 表示方法 </summary>

下面多次用到了 CIDR 的表示方法，格式是 a.b.c.d/len ，可能表示以下两种意义之一：

1. 地址是 a.b.c.d ，并且最高 len 位和 a.b.c.d 相同的 IP 地址都在同一个子网中，常见于对于一个网口的 IP 地址的描述。如 192.168.100.14/24 表示 192.168.100.14 的地址，地址掩码为 255.255.255.0 ，183.173.233.233/17 表示 183.173.233.233 的地址，地址掩码为 255.255.128.0 。
2. 描述一个地址段，此时 a.b.c.d 除了最高 len 位都为零，表示一个 IP 地址范围，常见于路由表。如 192.168.100.0/24 表示从 192.168.100.0 到 192.168.100.255 的地址范围，183.173.128.0/17 表示从 183.173.128.0 到 183.173.255.255 的地址范围。

</details>

### 实验第一部分

实验的第一部分目前共有四道题，要求同学们独立完成，助教会对代码进行人工检查和查重。需要实现的函数功能都在函数的注释中进行了阐述，评测所采用的数据都公开，如果出现了本地自测通过但在 OJ 上测试不通过的情况请找助教。

### 实验第二部分

实验的第二部分是针对个人的测试，你需要把你的软件运行在树莓派上，和我们提供的机器组成如下的拓扑：

![Topology](topology.png)

这一阶段，PC1、R1、R3、PC2 都由助教提供，两台路由器上均运行 BIRD 作为标准的路由软件实现。你的树莓派在 R2 的位置。其中 R2 实际用到的只有两个口，剩余两个口配置为 `10.0.2.1/24` 和 `10.0.3.1/24` 。初始情况下，R1 和 R3 先不启动 RIP 协议处理程序，这些机器的系统路由表如下：

```text
PC1:
default via 192.168.1.1 dev pc1r1
192.168.1.0/24 dev pc1r1 scope link
R1:
192.168.1.0/24 dev r1pc1 scope link
192.168.3.0/24 dev r1r2 scope link
R3:
192.168.4.0/24 dev r3r2 scope link
192.168.5.0/24 dev r3pc2 scope link
PC2:
default via 192.168.5.2 dev pc2r3
192.168.5.0/24 dev pc2r3 scope link
```

上面的每个网口名称格式都是两个机器拼接而成，如 `pc1r1` 代表 pc1 上通往 r1 的网口。此时，接上你的树莓派，按照图示连接两侧的 R1 和 R3 后，从 PC1 到 PC2 是不通的。接着，在 R1 和 R3 上都开启 RIP 协议处理程序，它们分别会在自己的 RIP 包中宣告 `192.168.1.0/24` 和 `192.168.5.0/24` 的路由。一段时间后它们的转发表（即直连路由 + RIP 收到的路由）应该变成这样：

```text
R1:
10.0.2.0/24 via 192.168.3.2 dev r1r2
10.0.3.0/24 via 192.168.3.2 dev r1r2
192.168.1.0/24 dev r1pc1 scope link
192.168.3.0/24 dev r1r2 scope link
192.168.4.0/24 via 192.168.3.2 dev r1r2
192.168.5.0/24 via 192.168.3.2 dev r1r2
R3:
10.0.2.0/24 via 192.168.4.1 dev r3r2
10.0.3.0/24 via 192.168.4.1 dev r3r2
192.168.1.0/24 via 192.168.4.1 dev r3r2
192.168.3.0/24 via 192.168.4.1 dev r3r2
192.168.4.0/24 dev r3r2 scope link
192.168.5.0/24 dev r3pc2 scope link
```

实际情况下，树莓派的网卡名字的分配规则是插入时选择最小的位被分配的数字，所以在验收的时候先插的是到 R1 的 USB 网卡，对应 eth1 ，然后再插到 R3 的 USB 网卡，对应 eth2 。

<details>
    <summary>检查内容和方法</summary>

我们将会逐项检查下列内容：

* PC1 是否与 PC2 能够正常通信：使用 `ping` 测试 ICMP、在一个 PC 上运行 `nc -l 80`，另一个 PC 上运行 `nc $pc_addr 80` 并输入内容回车测试 TCP 连接
* R2 的转发是否通过 HAL 完成，而非 Linux 自带的路由转发功能：在 R2 上使用 `ip a` 命令确认连接 R1 和 R3 的网口上没有配置 IP 地址
* R1、R3 上的 RIP 路由表是否正确：包括 RIP metric 等信息，从 R1 和 R3 上 运行的 BIRD 输出得到
* R2 向 R1、R3 发出的 RIP 协议报文是否正确：包括是否响应了请求，以及是否实现了水平分裂（split horizon）算法，在 R1 和 R3 上用 Wireshark 抓包检查
* R2 上的 RIP 路由表、转发表是否正确：需要你定期或者每次收到报文时打印最新的 RIP 路由表、系统转发表（见 FAQ 中对于路由表和转发表的讨论），格式自定，可以模仿 `ip route` 的输出格式

在 `Setup` 目录下存放了验收时在 R1 和 R3 上配置的脚本，还有恢复它的改动的脚本，注意它采用了树莓派中管理网络的 dhcpcd 进行地址的配置，所以可能不适用于树莓派以外的环境。 如果运行过配置脚本，请在验收前恢复它的改动，运行恢复脚本 `Setup/restore.sh` 即可，也可以手动删除 `/etc/dhcpcd.conf` 最后的几行内容然后用 `sudo systemctl restart dhcpcd` 来重启 dhcpcd 。简单起见，它采用了 netns 来模拟 PC1 和 PC2，这样只需要两个树莓派就可以进行联调和验收。

</details>

<details>
    <summary>为何不在 R2 上配置 IP 地址：192.168.3.2 和 192.168.4.1 </summary>

1. Linux 有自己的网络栈，如果配置了这两个地址，Linux 的网络栈也会进行处理，如 ARP 响应，ICMP 响应和（可以开启的）转发功能
2. 实验中你编写的路由器会运行在 R2 上，它会进行 ARP 响应（HAL 代码内实现）和 ICMP 响应（可选）和转发（你的代码实现），实际上做的和 Linux 网络栈的部分功能是一致的
3. 为了保证确实是你编写的路由器在工作而不是 Linux 网络栈在工作，所以不在 R2 上配置这两个 IP 地址

</details>

<details>
    <summary> 功能实现的要求 </summary>

必须实现的有：

1. 转发功能，支持直连路由和间接路由，包括查表，TTL 减一，Checksum 更新并转到正确的 interface 出去。
2. 周期性地向所有端口发送 RIP Response （建议在测试和验收时调为 5s），目标地址为 RIP 的组播地址。
3. 对收到的 RIP Request 有相应的 RIP Response 进行回复，目标地址为 RIP Request 的源地址。
4. 实现水平分割（split horizon）。
5. 收到 RIP Response 时，对路由表进行维护。需要注意的是，BIRD 实现了 reverse poisoning ，你需要注意这种情况。
6. 定期或者在更新的时候向 stdout/stderr 打印最新的 RIP 路由表。

可选实现的有（不加分，但对调试有帮助）：

1. 对 ICMP Echo Request 进行 ICMP Echo Reply 的回复。
2. 在查不到路由表的时候，回复 ICMP Host Unreachable。
3. 在 TTL 减为 0 时，回复 ICMP Time Exceeded。
4. 支持 RIP Entry 中 nexthop 不为 0 的情况。
5. 在路由表出现更新的时候发送 RIP Response（完整或者增量），目标地址为 RIP 的组播地址。
6. 在 split horizon 基础上实现 reverse poisoning 。
7. 路由的失效（Invalid）和删除（Flush）计时器。
8. 在发送的 RIP Response 出现不止 25 条 Entry 时拆分。
9. 程序启动时向所有 interface 发送 RIP Request，目标地址为 RIP 的组播地址。

不需要实现的有：

1. ARP 的处理。
2. IGMP 的处理。
3. interface 状态的跟踪（UP/DOWN 切换）。

</details>

此外，我们还将使用 `iperf3` 工具分别测试 PC1 和 PC2 双向进行 TCP 传输的速率。如果你的转发性能较高，可以获得额外的加分。同时，我们可能会进行代码和知识点的抽查。

<details>
    <summary> 容易出错的地方 </summary>

1. Metric 计算和更新方式不正确或者不在 [1,16] 的范围内
2. 没有正确处理 RIP Response 特别是 nexthop=0 的处理和 metric=16 的处理，参考 [RFC 2453 Section 4.4 Next Hop](https://tools.ietf.org/html/rfc2453#section-4.4) 和 [RFC 2453 Section 3.9.2 Response Messages](https://tools.ietf.org/html/rfc2453#page-26)
3. 转发的时候查表 not found ，还是路由表有问题
4. 更新路由表的时候，查询应该用精确匹配，但是错误地使用了最长前缀长度匹配
5. 没有对所有发出的 RIP Response 正确地实现水平分割
6. 端序不正确，可以通过 Wireshark 看出

</details>

<details>
    <summary> 可供参考的例子 </summary>

我们提供了 `host0.pcap` 和 `host1.pcap` ，分别是在 R1 和 R3 抓包的结果，模拟了实验的过程：

1. 开启 R1 R3 上的 BIRD 和 R2 上运行的路由器实现
2. 使用 ping 进行了若干次连通性测试

注意，这个例子中，路由器只实现了 split horizon，没有实现 reverse poisoning，你的实现不需要和它完全一样。Split horizon 的实现方法见 [RFC2452 3.4.3 Split horizon 第一段](https://tools.ietf.org/html/rfc2453#page-15)。

举个例子，从 PC1 到 PC2 进行 ping 连通性测试的网络活动（忽略 RIP）：

1. PC1 要 ping 192.168.5.1 ，查询路由表得知下一跳是 192.168.1.1 。
2. 假如 PC1 还不知道 192.168.1.1 的 MAC 地址，则发送源地址为 192.168.1.2 的 ARP 请求（通过 pc1r1）询问 192.168.1.1 的 MAC 地址。
3. R1 接收到 ARP 请求，回复 MAC 地址（r1pc1）给 PC1 （通过 r1pc1）。
4. PC1 把 ICMP 包发给 R1 ，目标 MAC 地址为上面 ARP 请求里回复的 MAC 地址，即 R1 的 MAC 地址（r1pc1）。
5. R1 接收到 IP 包，查询路由表得知下一跳是 192.168.3.2 ，假如它已经知道 192.168.3.2 的 MAC 地址。
6. R1 把 IP 包外层的源 MAC 地址改为自己的 MAC 地址（r1r2），目的 MAC 地址改为 192.168.3.2 的 MAC 地址（R2 的 r2r1），发给 R2（通过 r1r2）。
7. R2 接收到 IP 包，查询路由表得知下一跳是 192.168.4.2 ，假如它不知道 192.168.4.2 的 MAC 地址，所以丢掉这个 IP 包。
8. R2 发送源地址为 192.168.4.1 的 ARP 请求（通过 r2r3）询问 192.168.4.2 的 MAC 地址。
9. R3 接收到 ARP 请求，回复 MAC 地址（r3r2）给 R2（通过 r3r2）。
10. PC1 继续 ping 192.168.5.1，查询路由表得知下一跳是 192.168.1.1 。
11. PC1 把 ICMP 包发给 R1 ，目标 MAC 地址为 192.168.1.1 对应的 MAC 地址，源 MAC 地址为 192.168.1.2 对应的 MAC 地址。
12. R1 查表后把 ICMP 包发给 R2，目标 MAC 地址为 192.168.3.2 对应的 MAC 地址，源 MAC 地址为 192.168.3.1 对应的 MAC 地址。
13. R2 查表后把 ICMP 包发给 R3，目标 MAC 地址为 192.168.4.2 对应的 MAC 地址，源 MAC 地址为 192.168.4.1 对应的 MAC 地址。
14. R3 查表后把 ICMP 包发给 PC2，目标 MAC 地址为 192.168.5.1 对应的 MAC 地址，源 MAC 地址为 192.168.5.2 对应的 MAC 地址。
15. PC2 收到后响应，查表得知下一跳是 192.168.5.2 。
16. PC2 把 ICMP 包发给 R3，目标 MAC 地址为 192.168.5.2 对应的 MAC 地址，源 MAC 地址为 192.168.5.2 对应的 MAC 地址。
17. R3 把 ICMP 包发给 R2，目标 MAC 地址为 192.168.4.1 对应的 MAC 地址，源 MAC 地址为 192.168.4.2 对应的 MAC 地址。
18. R2 把 ICMP 包发给 R1，目标 MAC 地址为 192.168.3.1 对应的 MAC 地址，源 MAC 地址为 192.168.3.2 对应的 MAC 地址。
19. R1 把 ICMP 包发给 PC1，目标 MAC 地址为 192.168.1.2 对应的 MAC 地址，源 MAC 地址为 192.168.1.1 对应的 MAC 地址。
20. PC1 上 ping 显示成功。

</details>

### 实验第三部分

第三部分是针对组队的测试，一个组一般是三个人，网络拓扑与单人测试相同，只不过此时 R1、R2、R3 分别是三位同学的树莓派，我们会在验收前几天的某一时刻随机定下每组中哪一位同学分别对应 R1 R2 R3 的哪一个，所以同学们在测试的时候尽量测试各种组合。请注意，在实验中第三部分，在 PC1 R1 R2 R3 PC2 上都不需要运行 BIRD（如果安装了 BIRD 可以运行 `sudo systemctl disable --now bird` 以禁用 BIRD），也不需要打开 Linux 的转发功能。

<details>
    <summary> 测试和评分标准 </summary>

测试方法（2019.12.26 更新，同学可以选择跳过部分选项，满足部分即可拿到满分，超过满分部分舍去）：

1. 稳定性（15%）：对于下面的测试过程（3-9），如果测试过程中程序没有崩溃，即使没有通过测试，也可以得到每个测试 3% 的分数，15% 封顶
2. 协议基本实现（10%）：R1 可以学到 192.168.5.0/24 的路由，R3 可以学到 192.168.1.0/24 的路由，通过程序输出判断
3. 连通性（10%）：从 PC1 可以 ping 通 PC2
4. 连通延迟（10%）：在连通的基础上，在 PC1 上 ping PC2 的地址， 5s 取延迟的平均值，得到的百分比分值为 10*exp(-t/100) % ，其中 t 单位为 ms
5. 单连接单工大包（30%）：在 PC2 运行 `iperf3 -s`，在 PC1 运行 `iperf3 -c 192.168.5.1`，默认参数运行，得到的百分比分值为 30*(1-exp(-s/20)) % ，其中 s 单位为 Mbps
6. 单链接单工小包（30%）：在 PC2 运行 `iperf3 -s`，在 PC1 运行 `iperf3 -c 192.168.5.1 -u -l 16 -t 5 -b 1G`，在 PC2 计算 0.00-5.00 秒总共的 `(Total Datagrams - Lost) / 5s` ，得到的百分比分值为 30*(1-exp(-s)) % ，其中 s 单位为 Kilopackets / s
7. 小规模路由表压力测试（20%）：在 PC1 上开启 bird，配置 192.168.10.0/24 ~ 192.168.255.0/24 共 246 条新的路由，从 PC2 ping 192.168.10.1 （10%）和 192.168.255.1（10%），可以在 PC1 上抓到包
8. 中等规模路由表压力测试（30%）：在 PC1 上开启 bird，10.0.0.0/24 ~ 10.8.255.0/24 共 2048 条新路由，从 PC2 ping 10.1.2.3（15%） 和 10.8.7.6（15%），可以在 PC1 上抓到包
9. 较大规模路由表压力测试（45%）：在 PC1 上开启 bird，配置 AS4538 的所有 IPv4 路由（约 5000 条），从 PC2 ping 166.111.4.100 （15%）、101.6.4.100 （15%）和 59.66.134.1（15%），可以在 PC1 上抓到包
10. 其他扩展功能：经助教和老师同意可以获得每项不高于 10% 的分数

为了方便理解，你可以打开 `score.xlsx` 并在里面填入你的数据以计算出你能得到的分数。

</details>

PC1 和 PC2 的路由：

```text
PC1:
192.168.5.0/24 via 192.168.1.1 dev pc1r1
192.168.1.0/24 dev pc1r1 scope link
PC2:
192.168.1.0/24 via 192.168.5.2 dev pc2r3
192.168.5.0/24 dev pc2r3 scope link
```

初始情况下 R1 R2 R3 都只有对应的直连路由，只有在正确地运行 RIP 协议后，才能从 PC1 ping 通 PC2 。

验收的时候下，由于 PC1 和 PC2 只连接一个 USB 网卡，所以上面的 pc1r1 和 pc2r3 都是 eth1 。同学自由选择 R2 上两个 USB 网卡的插入顺序，但在 R1 上先插到 R2 的 USB 网卡，即 eth1 ，再插到 PC1 的 USB 网卡，即 eth2，在 R3 也是先插到 R2 的网卡，即 eth1 ，再插到 PC2 的 USB 网卡，即 eth2。这样规定的目的是方便替换 PC1/2 的设备，在验收的时候可以从同学自己的电脑直接换成树莓派。

同学在自己测试时，PC1 和 PC2 可以用自己的笔记本电脑，按照上面要求配置两条路由即可测试。配置静态路由的方法参考：[Windows](https://tekbloq.com/2018/10/24/how-to-add-a-static-route-to-the-windows-routing-table/) [macOS](https://blog.remibergsma.com/2012/03/04/howto-quickly-add-a-route-in-mac-osx/) [Linux](https://www.cyberciti.biz/faq/linux-route-add/) 。一般来说，在配置 IP 地址和子网掩码的时候直连路由自动就添加好了，只需要在 PC1 上添加 192.168.5.0/24 via 192.168.1.1 和在 PC2 上添加 192.168.1.0/24 via 192.168.5.2 即可。具体到 Linux 的命令，就是（假如 USB 网卡是 eth1）：

```text
PC1:
ip a add 192.168.1.2/24 dev eth1
ip r add 192.168.5.0/24 via 192.168.1.1 dev eth1
PC2:
ip a add 192.168.5.1/24 dev eth1
ip r add 192.168.1.0/24 via 192.168.5.2 dev eth1
```

对于路由表的压力测试，可以在 PC1 上使用 `Setup/bird1.conf` 覆盖 `/etc/bird/bird.conf` ，然后用 `sudo systemctl restart bird` 来启动 BIRD，如果你在 netns 中或者非树莓派的环境使用，可能需要修改 `Setup/bird1.conf` 和 `Setup/conf-part{7,8,9}.conf` 相关的网卡名字，并保证网卡处于 UP 状态。这个配置文件中有三个 part，分别对应上面流程中的 7 8 9 三步，可以通过 `sudo birdc disable part7` 和 `sudo birdc enable part7` 来启用/禁用某一组路由表，路由表的具体内容见 `conf-part{7,8,9}.conf` 文件。想要查看 BIRD 是否配置正确，可以运行 `sudo birdc show route` 来查看 BIRD 的完整路由表。

<details>
    <summary> 温馨提示 </summary>

容易出错的地方：

1. 自己或者队友的水平分割实现的不正确
2. RIP 中有一些字段不符合要求
3. USB 网卡的插入顺序不对
4. 直连路由配置不正确
5. PC1 和 PC2 配置不正确，ICMP 包根本没有发给 R1 和 R3
6. Windows 默认不响应 ICMP Echo Request，[解决方法](https://kb.iu.edu/d/aopy)
7. BIRD 配置不正确，如网卡名称和实际情况对不上

提升转发性能的方法：

1. 去掉转发时的调试输出
2. 增量更新 Checksum，[参考](https://tools.ietf.org/html/rfc1624)
3. 优化路由表查询算法

支持较大路由表的方法：

1. 发送 RIP Response 时按照 25 条为一组进行切分
2. 完善路由表更新算法
3. 完善路由表查询算法

</details>

如果想尝试更加复杂的网络拓扑，同学可以选择在 R1 和 R3 直接再连一条线（组成了环形网络，配置的 IP 地址自定），如果在这种情况下仍然可以实现 PC1 和 PC2 的连通，可以得到一定的加分，加分方法参考上面测试方法的最后一点。